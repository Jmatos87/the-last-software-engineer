# v1.15.0 Bug & Balance Pass Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix all simulation-identified bugs, implement 3 dead epic relics, add burn-amplifier and dodge-scaling card archetypes, add Architect Resonance/Harmonic system, and balance overtuned/undertuned cards across Frontend, Backend, and Architect.

**Architecture:** All changes are within the existing game engine. New card effects go through `executePlayCard` and `startNewTurn` in `battleActions.ts`. New types add fields to existing interfaces â€” no new files created. Resonance is a pure computation pass added after the existing engineer passive loop.

**Tech Stack:** TypeScript, React 19, Zustand + Immer. No test framework â€” verify each task with `npm run build` (TypeScript compile check).

---

## Task 1: Add new fields to types/index.ts

**Files:**
- Modify: `src/types/index.ts`

**What to add:**

**To `CardEffect` interface** (find `interface CardEffect` â€” it's around line 100, has 150+ fields):
```ts
// === NEW v1.15 fields ===
// Dodge-scaling (Frontend)
damagePerDodge?: number;               // deal N Ã— current dodge stacks as damage to target
bonusDamageIfDodgedThisTurn?: boolean; // deal bonusDamageIfDodgedThisTurnAmount if dodge fired this enemy turn
bonusDamageIfDodgedThisTurnAmount?: number;
dodgeScalesDamage?: number;            // power card: sets BattleState.dodgeScalesDamage to N (all attacks deal +N per dodge stack)
// Burn amplifiers (Backend)
doubleBurnOnTarget?: boolean;          // double target's burn stacks after dealing damage
tripleBurnOnTarget?: boolean;          // triple target's burn stacks after dealing damage
damagePerBurn?: number;                // deal N Ã— target's burn stacks as damage; use with consumeBurnOnHit
consumeBurnOnHit?: boolean;            // remove all burn from target after damagePerBurn resolves
burnDoTMultiplier?: number;            // power card: sets BattleState.burnDoTMultiplier to N
applyBurnAll?: number;                 // apply N burn to ALL enemies
```

**To `EngineerSlot` interface** (find `interface EngineerSlot` around line 211):
```ts
// Add after evokeEffect line:
harmonicEffect?: EngineerEvoke;   // fires when ALL slots match this same engineer id
```

**To `EngineerEvoke` interface** (find `interface EngineerEvoke` around line 193):
```ts
// Add these fields:
applyToSelf?: StatusEffect;                    // apply status to player on evoke
doublePlayerStatus?: boolean;                  // double all current player status effect stacks (for principal harmonic)
damageAllScalesWithCounterOffer?: number;      // deal counterOffer Ã— N to all enemies (for security harmonic)
```

**To `BattleState` interface** (find `interface BattleState` around line 444):
```ts
// After maxEngineerSlots line, add:
// v1.15 new mechanic fields
dodgedThisTurn: boolean;           // true if any dodge fired during this enemy turn; reset at turn start
dodgeScalesDamage: number;         // set by evasion_protocol power; adds +N per dodge to all attack damage
burnDoTMultiplier: number;         // set by thermal_cascade power; multiplies all burn tick damage (default 1)
circuitBreakerUsed: boolean;       // true once circuit_breaker relic has saved the player this combat
firstNCardsFreeRemaining: number;  // domain_model relic: first N cards played cost 0 (initialized in initBattle)
firstEngineerCardFreeUsed: boolean;// whiteboard_marker relic (redesigned): first engineer card costs 0
```

**Verify:** `npm run build` â€” must compile clean before proceeding.

---

## Task 2: Fix dodge decay bug â€” remove from tickStatusEffects, move to startNewTurn

**Files:**
- Modify: `src/utils/battleEngine.ts`
- Modify: `src/store/battleActions.ts`

**Problem:** Dodge currently decays inside `tickStatusEffects` (battleEngine.ts line 164). This function is also called for enemy status effects during the enemy turn, which runs once per enemy. While the PLAYER's tick only runs once (line 1526 in battleActions.ts), the semantic issue is that dodge also drains during the enemy turn rather than at the start of the player's own turn. The fix moves dodge decay to `startNewTurn` so players can see exactly when stacks expire.

**Step 1: Remove dodge from tickStatusEffects**

In `src/utils/battleEngine.ts`, find and remove this line (around line 164):
```ts
// REMOVE THIS LINE:
if (effects.dodge && effects.dodge > 0) newEffects.dodge = effects.dodge - 1;
```

Replace with (preserve dodge stacks unchanged in tick â€” they no longer auto-decay here):
```ts
// dodge decays in startNewTurn instead (player turn start)
if (effects.dodge && effects.dodge > 0) newEffects.dodge = effects.dodge;
```

**Step 2: Add dodge decay to startNewTurn**

In `src/store/battleActions.ts`, find `startNewTurn`. After the `const newBlock = ...` line (around line 1543) and before the discard phase, add:

```ts
// Decay dodge by 1 at start of player's turn (visible, predictable decay)
const prevDodge = battle.playerStatusEffects.dodge || 0;
const decayedDodge = prevDodge > 1 ? prevDodge - 1 : undefined;
```

Then when constructing the returned battle state (near the end of startNewTurn, where `playerStatusEffects` is assembled), apply the decayed dodge. Find the line that sets `playerStatusEffects` in the return object and ensure dodge uses `decayedDodge`.

Actually simpler â€” find the engineer passive section (around line 1687) which already assembles playerStatusEffects. Before the return, add:
```ts
// Apply dodge decay: lose 1 stack at turn start
if (newBattle.playerStatusEffects.dodge && newBattle.playerStatusEffects.dodge > 0) {
  newBattle.playerStatusEffects.dodge = newBattle.playerStatusEffects.dodge > 1
    ? newBattle.playerStatusEffects.dodge - 1
    : undefined;
}
// Reset per-turn flags
newBattle.dodgedThisTurn = false;
```

**Step 3: Initialize new BattleState fields in initBattle**

In `src/store/battleActions.ts`, find `initBattle` function. Locate the large return object (around line 242) and add alongside `firstPowerPlayedThisCombat: false`:
```ts
dodgedThisTurn: false,
dodgeScalesDamage: 0,
burnDoTMultiplier: 1,
circuitBreakerUsed: false,
firstNCardsFreeRemaining: 0,
firstEngineerCardFreeUsed: false,
```

**Verify:** `npm run build`

---

## Task 3: Fix bleed kills earning 0 gold + technical_debt upgrade stress

**Files:**
- Modify: `src/store/battleActions.ts` (startNewTurn function)

**Problem 1:** Bleed kill gold/count is computed locally in startNewTurn but discarded via `void bleedKillCount; void bleedGoldEarned;` around line 1671.

Find those lines and replace:
```ts
// REMOVE:
void bleedKillCount; void bleedGoldEarned;

// REPLACE WITH:
newBattle.killCount = (newBattle.killCount || 0) + bleedKillCount;
newBattle.goldEarned = (newBattle.goldEarned || 0) + bleedGoldEarned;
```

**Problem 2:** Curse stress is hardcoded to 5 per curse (around line 1578):
```ts
// CURRENT:
const cursesDrawn = hand.filter(c => c.type === 'curse').length;
if (cursesDrawn > 0) stressChange += cursesDrawn * 5;
```

Replace with per-curse stress reading:
```ts
const cursesDrawn = hand.filter(c => c.type === 'curse');
if (cursesDrawn.length > 0) {
  const curseStress = cursesDrawn.reduce((sum, curse) => {
    // Upgraded technical_debt says 3; base says 5; default to 5
    return sum + (curse.effects?.stress ?? 5);
  }, 0);
  stressChange += curseStress;
}
```

Also add `stress?: number` to `CardEffect` if it's not already there (check types/index.ts â€” it may be missing from the interface even though technical_debt uses it).

**Verify:** `npm run build`

---

## Task 4: Implement circuit_breaker relic + set dodgedThisTurn flag

**Files:**
- Modify: `src/store/battleActions.ts` (executeEnemyTurn function)

**Goal 1:** After damage is applied to the player (all move types: attack, dual_attack, attack_defend), if the result would kill the player AND `circuit_breaker` relic is present AND `!newBattle.circuitBreakerUsed`, clamp HP to 1.

Find the section after `applyDamageToPlayer` calls in executeEnemyTurn. The function returns `{ battle: newBattle, playerHp, playerStress, ... }`. Add this block BEFORE the return statement (around line 1528):

```ts
// circuit_breaker relic: survive killing blow once per combat
if (playerHp <= 0 && !newBattle.circuitBreakerUsed) {
  const hasCircuitBreaker = run.items.some(i => i.effect.surviveKillingBlow);
  if (hasCircuitBreaker) {
    playerHp = 1;
    newBattle.circuitBreakerUsed = true;
  }
}
```

**Goal 2:** Set `dodgedThisTurn = true` when any dodge fires. Find each dodge check in executeEnemyTurn (there are 3: for attack, dual_attack, attack_defend types â€” around lines 1171, 1227, 1370). Each looks like:
```ts
const dodgeStacks = newBattle.playerStatusEffects.dodge || 0;
if (dodgeStacks > 0 && Math.random() < dodgeStacks * 0.1) {
  // dodge fired â€” set the flag here
  newBattle.dodgedThisTurn = true;
  // ... rest of dodge handling
```

Add `newBattle.dodgedThisTurn = true;` inside each of the 3 dodge-success branches.

**Verify:** `npm run build`

---

## Task 5: Implement domain_model relic (firstNCardsFree) + whiteboard_marker redesign

**Files:**
- Modify: `src/store/battleActions.ts` (initBattle + executePlayCard)
- Modify: `src/data/items.ts`

**Step 1: domain_model in initBattle**

In `initBattle`, after the opening hand is drawn and all relic start-of-combat effects are applied, add:
```ts
// domain_model relic: first N cards played cost 0
const domainModelRelic = run.items.find(i => i.effect.firstNCardsFree);
if (domainModelRelic) {
  initialBattle.firstNCardsFreeRemaining = domainModelRelic.effect.firstNCardsFree!;
}
```
(`initialBattle` is the BattleState object being constructed â€” use whatever variable name is used in initBattle's return.)

**Step 2: domain_model in executePlayCard cost check**

In `executePlayCard`, find the cost-check section (around lines 277-295). Add BEFORE `if (effectiveCost > battle.energy)`:
```ts
// domain_model relic: first N cards cost 0
if ((battle.firstNCardsFreeRemaining || 0) > 0) {
  effectiveCost = 0;
}
```

After the card is successfully played (after `newBattle.energy -= effectiveCost`), decrement the counter:
```ts
if ((battle.firstNCardsFreeRemaining || 0) > 0) {
  newBattle.firstNCardsFreeRemaining = battle.firstNCardsFreeRemaining - 1;
}
```

**Step 3: Redesign whiteboard_marker in items.ts**

Find `whiteboard_marker` in `src/data/items.ts` (around line 20):
```ts
// CURRENT:
effect: { firstPowerFree: true },

// CHANGE TO:
effect: { firstEngineerCardFree: true },
```

Also update its description:
```ts
// CHANGE TO:
description: 'First Engineer card each combat costs 0. Uncapped. Dried out. Still works.',
```

**Step 4: firstEngineerCardFree in executePlayCard**

In `executePlayCard`, find the existing `firstPowerFree` check (around line 278):
```ts
if (card.type === 'power' && !battle.firstPowerPlayedThisCombat) {
  const hasFreeFirstPower = run.items.some(i => i.effect.firstPowerFree);
  if (hasFreeFirstPower) effectiveCost = 0;
}
```

Add a new check directly after it:
```ts
// whiteboard_marker (redesigned): first engineer slot card costs 0
if (effects.slotEngineer && !battle.firstEngineerCardFreeUsed) {
  const hasFreeFirstEngineer = run.items.some(i => i.effect.firstEngineerCardFree);
  if (hasFreeFirstEngineer) effectiveCost = 0;
}
```

Then find where `firstPowerPlayedThisCombat` is set to true (around line 820, when a power card is played). Nearby or in the engineer slot section, add:
```ts
// Set firstEngineerCardFreeUsed when an engineer card is played free
if (effects.slotEngineer && !newBattle.firstEngineerCardFreeUsed) {
  const hasFreeFirstEngineer = run.items.some(i => i.effect.firstEngineerCardFree);
  if (hasFreeFirstEngineer) newBattle.firstEngineerCardFreeUsed = true;
}
```

Also add `firstEngineerCardFree?: boolean` to `ItemEffect` interface in `types/index.ts` (find `interface ItemEffect` around line 375).

**Verify:** `npm run build`

---

## Task 6: Implement skillBlockMultiplier relic (css_custom_props)

**Files:**
- Modify: `src/utils/battleEngine.ts` (calculateBlock)
- Modify: `src/store/battleActions.ts` (all calls to calculateBlock from skill cards)

**Current calculateBlock signature** (around line 61):
```ts
export function calculateBlock(base: number, statusEffects: StatusEffect, items: ItemDef[]): number
```

**Step 1: Add multiplier parameter**

Change signature to:
```ts
export function calculateBlock(
  base: number,
  statusEffects: StatusEffect,
  items: ItemDef[],
  isSkillCard: boolean = false
): number
```

At the end of `calculateBlock` (before return), add:
```ts
// css_custom_props relic: block from skills increased by 50%
if (isSkillCard && items.some(i => i.effect.skillBlockMultiplier)) {
  const multiplier = items.find(i => i.effect.skillBlockMultiplier)!.effect.skillBlockMultiplier! / 100;
  total = Math.ceil(total * multiplier);
}
```

**Step 2: Pass isSkillCard to block calculations**

In `executePlayCard` in `battleActions.ts`, find every call to `calculateBlock(...)`. Pass `card.type === 'skill'` as the 4th argument:
```ts
calculateBlock(effects.block, newBattle.playerStatusEffects, run.items, card.type === 'skill')
```

There are multiple `calculateBlock` calls â€” update all of them.

**Verify:** `npm run build`

---

## Task 7: Add burn-amplifier effects to executePlayCard and startNewTurn

**Files:**
- Modify: `src/store/battleActions.ts`

**Step 1: Handle burn-amplifier effects in executePlayCard**

Find the section in `executePlayCard` where enemy status effects are applied after damage (around where `doubleTargetBleed` is handled â€” search for `doubleTargetBleed`). After that block, add:

```ts
// doubleBurnOnTarget: double burn stacks on target after damage
if (effects.doubleBurnOnTarget && targetEnemyIdx >= 0) {
  const currentBurn = newBattle.enemies[targetEnemyIdx].statusEffects.burn || 0;
  if (currentBurn > 0) {
    newBattle.enemies[targetEnemyIdx] = {
      ...newBattle.enemies[targetEnemyIdx],
      statusEffects: mergeStatusEffects(
        { ...newBattle.enemies[targetEnemyIdx].statusEffects, burn: undefined },
        { burn: currentBurn * 2 }
      ),
    };
  }
}

// tripleBurnOnTarget: triple burn stacks on target
if (effects.tripleBurnOnTarget && targetEnemyIdx >= 0) {
  const currentBurn = newBattle.enemies[targetEnemyIdx].statusEffects.burn || 0;
  if (currentBurn > 0) {
    newBattle.enemies[targetEnemyIdx] = {
      ...newBattle.enemies[targetEnemyIdx],
      statusEffects: mergeStatusEffects(
        { ...newBattle.enemies[targetEnemyIdx].statusEffects, burn: undefined },
        { burn: currentBurn * 3 }
      ),
    };
  }
}

// damagePerBurn: deal N Ã— target's burn stacks as additional damage
if (effects.damagePerBurn && targetEnemyIdx >= 0) {
  const targetBurn = newBattle.enemies[targetEnemyIdx].statusEffects.burn || 0;
  if (targetBurn > 0) {
    const burnDamage = calculateDamage(effects.damagePerBurn * targetBurn, newBattle.playerStatusEffects, run.items, newBattle.enemies[targetEnemyIdx].statusEffects);
    newBattle.enemies[targetEnemyIdx] = applyDamageToEnemy({ ...newBattle.enemies[targetEnemyIdx] }, burnDamage);
    if (effects.consumeBurnOnHit) {
      newBattle.enemies[targetEnemyIdx] = {
        ...newBattle.enemies[targetEnemyIdx],
        statusEffects: { ...newBattle.enemies[targetEnemyIdx].statusEffects, burn: undefined },
      };
    }
    // Gold/kill tracking for burn kills
    if (newBattle.enemies[targetEnemyIdx].currentHp <= 0) {
      newBattle.goldEarned = (newBattle.goldEarned || 0) + (newBattle.enemies[targetEnemyIdx].gold || 0);
      newBattle.killCount = (newBattle.killCount || 0) + 1;
    }
  }
}

// applyBurnAll: apply N burn to all enemies
if (effects.applyBurnAll) {
  newBattle.enemies = newBattle.enemies.map(e => ({
    ...e,
    statusEffects: mergeStatusEffects(e.statusEffects, { burn: effects.applyBurnAll }),
  }));
}

// burnDoTMultiplier: power card â€” set BattleState multiplier
if (effects.burnDoTMultiplier) {
  newBattle.burnDoTMultiplier = effects.burnDoTMultiplier;
}
```

**Step 2: Apply burnDoTMultiplier in startNewTurn burn tick**

Find the burn damage section in `startNewTurn` (around line 1676):
```ts
const burnDmg = e.statusEffects.burn || 0;
if (burnDmg <= 0) return e;
const damaged = applyDamageToEnemy({ ...e, statusEffects: { ...e.statusEffects } }, burnDmg);
```

Change to apply the multiplier:
```ts
const burnDmg = e.statusEffects.burn || 0;
if (burnDmg <= 0) return e;
const burnMultiplier = newBattle.burnDoTMultiplier || 1;
const damaged = applyDamageToEnemy({ ...e, statusEffects: { ...e.statusEffects } }, Math.floor(burnDmg * burnMultiplier));
```

**Verify:** `npm run build`

---

## Task 8: Add dodge-scaling effects to executePlayCard

**Files:**
- Modify: `src/store/battleActions.ts` (executePlayCard)

**Step 1: Handle dodgeScalesDamage power card**

In `executePlayCard`, find where power cards are handled (around line 819 where `firstPowerPlayedThisCombat` is set). Add:
```ts
// evasion_protocol power: attacks scale with dodge stacks
if (effects.dodgeScalesDamage) {
  newBattle.dodgeScalesDamage = effects.dodgeScalesDamage;
}
```

**Step 2: Apply dodgeScalesDamage to all attack damage calculations**

Find in `executePlayCard` where `effects.damage` is processed for single-target attacks. Look for the main damage block (search for `calculateDamage(effects.damage`). The dodge bonus should be added to the BASE value before calculateDamage:

```ts
// Add dodge scaling to attack damage
const dodgeBonus = (newBattle.dodgeScalesDamage || 0) * (newBattle.playerStatusEffects.dodge || 0);
const scaledDamage = (effects.damage || 0) + dodgeBonus;
// Then use scaledDamage instead of effects.damage in the calculateDamage call
```

Apply the same bonus wherever `effects.damage` is used for attacking (single target, AoE `damageAll`, etc.).

**Step 3: Handle damagePerDodge**

Find a good place in `executePlayCard` after the `effects` variable is set (around line 319). Add:
```ts
// damagePerDodge: deal N Ã— current dodge stacks as damage
if (effects.damagePerDodge && targetInstanceId) {
  const dodgeStacks = newBattle.playerStatusEffects.dodge || 0;
  if (dodgeStacks > 0) {
    const dodgeDamage = calculateDamage(
      effects.damagePerDodge * dodgeStacks,
      newBattle.playerStatusEffects,
      run.items,
      enemyTarget?.statusEffects || {}
    );
    newBattle.enemies[targetEnemyIdx] = applyDamageToEnemy({ ...newBattle.enemies[targetEnemyIdx] }, dodgeDamage);
  }
}
```

**Step 4: Handle bonusDamageIfDodgedThisTurn**

```ts
// bonusDamageIfDodgedThisTurn: bonus damage if dodge fired this enemy turn
if (effects.bonusDamageIfDodgedThisTurnAmount && newBattle.dodgedThisTurn && targetInstanceId) {
  const bonusDmg = calculateDamage(
    effects.bonusDamageIfDodgedThisTurnAmount,
    newBattle.playerStatusEffects,
    run.items,
    enemyTarget?.statusEffects || {}
  );
  newBattle.enemies[targetEnemyIdx] = applyDamageToEnemy({ ...newBattle.enemies[targetEnemyIdx] }, bonusDmg);
}
```

**Verify:** `npm run build`

---

## Task 9: Add Architect Resonance/Harmonic system

**Files:**
- Modify: `src/store/battleActions.ts` (startNewTurn)
- Modify: `src/data/engineers.ts` (add harmonicEffect to each engineer)

**Step 1: Add harmonicEffect definitions to engineers.ts**

Open `src/data/engineers.ts`. The file has `engineerRoster: Record<string, EngineerSlot>`. Each entry has `passiveEffect` and `evokeEffect`. Add `harmonicEffect` to each:

```ts
// devops_engineer:
harmonicEffect: { energy: 3, draw: 3 },

// qa_engineer:
harmonicEffect: { applyToAll: { vulnerable: 3, weak: 3 } },

// security_engineer:
harmonicEffect: { damageAllScalesWithCounterOffer: 3 },

// data_engineer:
harmonicEffect: { draw: 10, shuffleDiscardToDraw: true },

// frontend_jr:
harmonicEffect: { applyToSelf: { dodge: 8 }, applyToAll: { bleed: 6 } },

// frontend_sr:
harmonicEffect: { applyToSelf: { dodge: 10 }, applyToAll: { bleed: 8 }, damageAll: 8 },

// backend_jr:
harmonicEffect: { queueBlock: 16, queueDamageAll: 16, queueChain: 16 },

// backend_sr:
harmonicEffect: { queueBlock: 20, queueDamageAll: 20, queueChain: 20 },

// ai_jr:
harmonicEffect: { damageAllScalesWithTokens: 3 },

// ai_sr:
harmonicEffect: { damageAllScalesWithTokens: 5 },

// principal_engineer:
harmonicEffect: { doublePlayerStatus: true },
```

**Step 2: Implement applyEvokeEffect for new fields**

In `battleActions.ts`, find `applyEvokeEffect` (around line 25). Add handlers for new EngineerEvoke fields:

```ts
// applyToSelf: apply status effects to player
if (evoke.applyToSelf) {
  b.playerStatusEffects = mergeStatusEffects(b.playerStatusEffects, evoke.applyToSelf);
}

// doublePlayerStatus: double all current player status stacks
if (evoke.doublePlayerStatus) {
  const current = b.playerStatusEffects;
  b.playerStatusEffects = mergeStatusEffects(current, {
    confidence: current.confidence || undefined,
    resilience: current.resilience || undefined,
    dodge: current.dodge || undefined,
    counterOffer: current.counterOffer || undefined,
    regen: current.regen || undefined,
    networking: current.networking || undefined,
    selfCare: current.selfCare || undefined,
    savingsAccount: current.savingsAccount || undefined,
  });
}

// damageAllScalesWithCounterOffer: deal counterOffer Ã— N to all enemies
if (evoke.damageAllScalesWithCounterOffer) {
  const counterOffer = b.playerStatusEffects.counterOffer || 0;
  const damage = counterOffer * evoke.damageAllScalesWithCounterOffer;
  if (damage > 0) {
    b.enemies = b.enemies.map(e => applyDamageToEnemy({ ...e }, damage));
  }
}
```

**Step 3: Add Resonance/Harmonic pass to startNewTurn**

In `startNewTurn`, find the engineer passive loop (around line 1687-1724). This loop fires each passive once. AFTER this loop (not inside it), add:

```ts
// â”€â”€ Resonance: adjacent matching slots fire passive again â”€â”€
const slots = newBattle.engineerSlots || [];
if (slots.length >= 2) {
  for (let i = 0; i < slots.length - 1; i++) {
    if (slots[i].id === slots[i + 1].id) {
      // Adjacent pair match â€” fire that passive a second time
      const passive = slots[i].passiveEffect;
      if (passive.energy) turnEnergy += passive.energy;
      if (passive.block) newBattle.playerBlock = (newBattle.playerBlock || 0) + passive.block;
      if (passive.draw) {
        // Draw extra cards (add to draw count for this turn â€” handled via extraDraw addition)
        // Simplest: draw cards inline using same drawCards logic used above
        for (let d = 0; d < passive.draw; d++) {
          if (newBattle.drawPile.length === 0) {
            newBattle.drawPile = shuffle([...newBattle.discardPile]);
            newBattle.discardPile = [];
          }
          if (newBattle.drawPile.length > 0) {
            newBattle.hand.push(newBattle.drawPile.pop()!);
          }
        }
      }
      if (passive.vulnerableRandom && newBattle.enemies.length > 0) {
        const randIdx = Math.floor(Math.random() * newBattle.enemies.length);
        newBattle.enemies[randIdx] = {
          ...newBattle.enemies[randIdx],
          statusEffects: mergeStatusEffects(newBattle.enemies[randIdx].statusEffects, { vulnerable: passive.vulnerableRandom }),
        };
      }
      if (passive.queueBlock) {
        newBattle.detonationQueue = [...(newBattle.detonationQueue || []), { type: 'block', value: passive.queueBlock, name: 'Ice Block (Resonance)' }];
      }
      // (Add other passive types as needed following the same pattern as the main passive loop above)
    }
  }
}

// â”€â”€ Harmonic: all slots match â†’ fire all passives a third time + harmonicEffect â”€â”€
if (slots.length >= 2 && slots.every(s => s.id === slots[0].id)) {
  // Fire all passives a third time (same logic as resonance loop but for all)
  for (const slot of slots) {
    const passive = slot.passiveEffect;
    if (passive.energy) turnEnergy += passive.energy;
    if (passive.block) newBattle.playerBlock = (newBattle.playerBlock || 0) + passive.block;
    if (passive.vulnerableRandom && newBattle.enemies.length > 0) {
      const randIdx = Math.floor(Math.random() * newBattle.enemies.length);
      newBattle.enemies[randIdx] = {
        ...newBattle.enemies[randIdx],
        statusEffects: mergeStatusEffects(newBattle.enemies[randIdx].statusEffects, { vulnerable: passive.vulnerableRandom }),
      };
    }
    // (mirror the resonance loop for all passive fields)
  }
  // Fire the harmonic effect of the matched engineer (once)
  if (slots[0].harmonicEffect) {
    newBattle = applyEvokeEffect(newBattle, slots[0].harmonicEffect, run);
  }
}
```

Note: `turnEnergy` is a local variable assembled in startNewTurn before being applied to `newBattle.energy`. Find where it's defined and ensure the resonance additions go in the right scope. If energy is applied differently, adapt accordingly.

**Verify:** `npm run build`

---

## Task 10: Fix restructure card + 404_not_found upgrade

**Files:**
- Modify: `src/store/battleActions.ts` (executePlayCard â€” removeEngineerSlot handling)
- Modify: `src/data/cards/frontendCards.ts` (404_not_found upgrade)

**Fix restructure (removeEngineerSlot):**

Find in `executePlayCard` the `removeEngineerSlot` handler (around line 1022):
```ts
if (effects.removeEngineerSlot) {
  newBattle.maxEngineerSlots = Math.max(1, (newBattle.maxEngineerSlots || 3) - effects.removeEngineerSlot);
  while ((newBattle.engineerSlots || []).length > newBattle.maxEngineerSlots) {
```

Change to explicitly evoke oldest regardless of overflow:
```ts
if (effects.removeEngineerSlot) {
  newBattle.maxEngineerSlots = Math.max(1, (newBattle.maxEngineerSlots || 3) - effects.removeEngineerSlot);
  // Unconditionally evoke oldest slot (even if no overflow â€” card says "evoke oldest")
  if ((newBattle.engineerSlots || []).length > 0) {
    const evoked = newBattle.engineerSlots.shift()!;
    newBattle = applyEvokeEffect(newBattle, evoked.evokeEffect, run);
  }
  // Then handle any remaining overflow
  while ((newBattle.engineerSlots || []).length > newBattle.maxEngineerSlots) {
    const evoked2 = newBattle.engineerSlots.shift()!;
    newBattle = applyEvokeEffect(newBattle, evoked2.evokeEffect, run);
  }
}
```

**Fix 404_not_found upgrade (no more exhaust on upgraded version):**

Find `404_not_found` in `src/data/cards/frontendCards.ts`. It has `exhaust: true` on the base card definition. The upgrade should NOT exhaust. Add to the card:
```ts
upgradedExhaust: false,  // upgraded version is NOT exhausted
```

Then in `executePlayCard`, when determining if a card exhausts, use:
```ts
const shouldExhaust = card.upgraded
  ? (card.upgradedExhaust !== undefined ? card.upgradedExhaust : card.exhaust)
  : card.exhaust;
```

Check if `upgradedExhaust` already exists in the `CardDef` type. If not, add `upgradedExhaust?: boolean` to the `CardDef` interface in `types/index.ts`.

Also update the `upgradedDescription` for `404_not_found` to say "Deal 8. Flow overflow triggers immediately. (Upgraded: no Exhaust)"

**Verify:** `npm run build`

---

## Task 11: Frontend card balance changes

**Files:**
- Modify: `src/data/cards/frontendCards.ts`

Search each card by its `id:` field. Make these changes:

**NERFS:**

`flow_state` (legendary):
```ts
// Find: upgradedCost: 0
// Change to:
upgradedCost: 1,
// Update upgradedDescription accordingly
```

`pointer-events: none` (rare):
```ts
// Find upgradedEffects for pointer-events: none
// Change from { applyToSelf: { dodge: 7, resilience: 3 } } (or similar) to:
upgradedEffects: { applyToSelf: { dodge: 6, resilience: 2 } },
// Base stays at dodge: 5, resilience: 2
```

`burst_split` (rare):
```ts
// Find upgradedEffects
// Change from { gainExtraFlow: 4, energy: 2, exhaust: true } to:
upgradedEffects: { gainExtraFlow: 3, energy: 1, exhaust: true },
```

`frame_perfect` (epic):
```ts
// Find upgradedCost
// Change from 0 to:
upgradedCost: 1,
// Keep upgradedEffects at 5 bleed + 4 dodge
```

**BUFFS:**

`z_axis_slip` (common):
```ts
// Add draw to effects:
effects: { applyToSelf: { dodge: 3 }, draw: 1 },
upgradedEffects: { applyToSelf: { dodge: 4 }, draw: 1 },
// Update descriptions
```

`absolute_position` (common):
```ts
// Add block to effects:
effects: { applyToSelf: { dodge: 2 }, block: 5 },
upgradedCost: 0,
upgradedEffects: { applyToSelf: { dodge: 2 }, block: 5 },
// description: "Gain 2 Dodge. Gain 5 Block."
// upgradedDescription: "Cost 0. Gain 2 Dodge. Gain 5 Block."
```

`deferred_load` (rare):
```ts
cost: 1,  // was 2
upgradedCost: 0,
upgradedEffects: { applyToSelf: { dodge: 6 }, block: 10 },
```

`ghost_cursor` (common, 0-cost):
```ts
// Add flow to effects (gainExtraFlow: 1 means +2 flow total when played):
effects: { damage: 3, applyToSelf: { dodge: 1 }, gainExtraFlow: 1 },
// description: "Deal 3. Gain 1 Dodge. Gain 1 extra Flow."
```

`minify` (common, 0-cost):
```ts
// Add draw to effects:
effects: { reduceNextCardCost: 2, draw: 1 },
// description: "Reduce next card's cost by 2. Draw 1."
```

**NEW CARDS â€” add to the frontendCards array:**

```ts
// --- Dodge-Scaling ---
{
  id: 'evasion_protocol',
  name: 'Evasion Protocol',
  icon: 'ðŸ›¡ï¸',
  class: 'frontend',
  type: 'power',
  rarity: 'rare',
  cost: 2,
  description: 'While you have Dodge, attacks deal +2 damage per Dodge stack.',
  upgradedDescription: 'While you have Dodge, attacks deal +3 damage per Dodge stack.',
  effects: { dodgeScalesDamage: 2 },
  upgradedEffects: { dodgeScalesDamage: 3 },
  archetype: 'evasion',
},
{
  id: 'counter_step',
  name: 'Counter Step',
  icon: 'âš¡',
  class: 'frontend',
  type: 'attack',
  rarity: 'rare',
  cost: 1,
  description: 'Deal 3 damage per Dodge stack.',
  upgradedDescription: 'Deal 4 damage per Dodge stack.',
  effects: { damagePerDodge: 3 },
  upgradedEffects: { damagePerDodge: 4 },
  archetype: 'evasion',
},
{
  id: 'phase_counter',
  name: 'Phase Counter',
  icon: 'ðŸ‘»',
  class: 'frontend',
  type: 'attack',
  rarity: 'epic',
  cost: 2,
  exhaust: true,
  description: 'Deal 8 damage. If you dodged this turn, deal 8 more.',
  upgradedDescription: 'Deal 12 damage. If you dodged this turn, deal 12 more. Exhaust.',
  effects: { damage: 8, bonusDamageIfDodgedThisTurn: true, bonusDamageIfDodgedThisTurnAmount: 8 },
  upgradedEffects: { damage: 12, bonusDamageIfDodgedThisTurn: true, bonusDamageIfDodgedThisTurnAmount: 12 },
  archetype: 'evasion',
},
```

**Verify:** `npm run build`

---

## Task 12: Backend card balance changes

**Files:**
- Modify: `src/data/cards/backendCards.ts`

**NERFS:**

`event_storm` (rare):
```ts
// Find event_storm. Change queued chain value from 25 to 16:
effects: { ..., queueChain: 16 },
upgradedEffects: { ..., queueChain: 20 },
// Update descriptions
```

`elemental_convergence` (epic):
```ts
// Find elemental_convergence. Change queue values from 15/15/15 to 10/10/10:
effects: { ..., queueBlock: 10, queueDamageAll: 10, queueChain: 10, ... },
upgradedEffects: { ..., queueBlock: 12, queueDamageAll: 12, queueChain: 12, ... },
```

**BUFFS:**

`connection_pool` (common):
```ts
// Add queueBlock to effects:
effects: { block: 8, queueBlock: 6 },
upgradedEffects: { block: 10, queueBlock: 8 },
// description: "Gain 8 Block. Schedule 6 Block for next turn."
```

`pub_sub_event` (common):
```ts
cost: 0,  // was 1
// description and upgradedDescription: update "Cost 0."
```

`kubernetes_pod` (rare):
```ts
// Simplify â€” remove deployment mechanic entirely:
effects: { block: 10, queueBlock: 14 },
upgradedEffects: { block: 12, queueBlock: 18 },
cost: 2,
description: 'Gain 10 Block. Schedule 14 Block for next turn. [â˜ï¸ Ice]',
upgradedDescription: 'Gain 12 Block. Schedule 18 Block for next turn. [â˜ï¸ Ice]',
// Remove any deploymentEffect or blockPerTurn fields
```

**NEW CARDS â€” add to backendCards array:**

```ts
{
  id: 'fuel_injection',
  name: 'Fuel Injection',
  icon: 'ðŸ”¥',
  class: 'backend',
  type: 'attack',
  rarity: 'rare',
  cost: 1,
  description: 'Deal 8 damage. Double Burn on target.',
  upgradedDescription: 'Deal 10 damage. Triple Burn on target.',
  effects: { damage: 8, doubleBurnOnTarget: true },
  upgradedEffects: { damage: 10, tripleBurnOnTarget: true },
  archetype: 'burn',
},
{
  id: 'backdraft',
  name: 'Backdraft',
  icon: 'ðŸ’¥',
  class: 'backend',
  type: 'attack',
  rarity: 'epic',
  cost: 2,
  exhaust: true,
  description: 'Deal damage equal to Burn stacks Ã— 5. Remove Burn. Exhaust.',
  upgradedDescription: 'Deal damage equal to Burn stacks Ã— 6. Remove Burn. Exhaust.',
  effects: { damagePerBurn: 5, consumeBurnOnHit: true },
  upgradedEffects: { damagePerBurn: 6, consumeBurnOnHit: true },
  archetype: 'burn',
},
{
  id: 'thermal_cascade',
  name: 'Thermal Cascade',
  icon: 'ðŸŒ¡ï¸',
  class: 'backend',
  type: 'power',
  rarity: 'epic',
  cost: 2,
  description: 'Burn ticks deal Ã—2 damage.',
  upgradedDescription: 'Burn ticks deal Ã—3 damage.',
  effects: { burnDoTMultiplier: 2 },
  upgradedEffects: { burnDoTMultiplier: 3 },
  archetype: 'burn',
},
{
  id: 'incendiary_comment',
  name: 'Incendiary Comment',
  icon: 'ðŸ”¥',
  class: 'backend',
  type: 'skill',
  rarity: 'rare',
  cost: 1,
  description: 'Apply 4 Burn to all enemies.',
  upgradedDescription: 'Apply 5 Burn to all enemies.',
  effects: { applyBurnAll: 4 },
  upgradedEffects: { applyBurnAll: 5 },
  archetype: 'burn',
},
```

**Verify:** `npm run build`

---

## Task 13: Architect card balance changes

**Files:**
- Modify: `src/data/cards/architectCards.ts`

**Fix ai_jr passive (in engineers.ts, not architectCards.ts):**

Open `src/data/engineers.ts`, find `ai_jr`:
```ts
// Change passive from generateTokens to draw:
passiveEffect: { draw: 1 },  // was { generateTokens: 1 }
// Keep evoke as-is: deal 10 + tokensÃ—2 to random enemy
```

Update the ai_jr engineer card description in `architectCards.ts` to say "Passive: Draw 1 card/turn."

**Fix over_engineering (rare):**

Find `over_engineering` in `architectCards.ts`:
```ts
// Remove addScopeCreepToDiscard. Change to pure nuke:
effects: { damage: 40, exhaust: true },
upgradedEffects: { damage: 50, exhaust: true },
description: 'Deal 40 damage. Exhaust. No notes. No survivors.',
upgradedDescription: 'Deal 50 damage. Exhaust.',
```

**Nerf domain_driven_design (epic):**

Find `domain_driven_design`:
```ts
// Change damagePerSlot from 12 to 9 (base), 12 (upgraded):
effects: { damagePerSlot: 9 },
upgradedEffects: { damagePerSlot: 12 },
description: 'Deal 9 damage per slotted Engineer.',
upgradedDescription: 'Deal 12 damage per slotted Engineer.',
```

**Verify:** `npm run build`

---

## Task 14: Add UI indicator for Resonance/Harmonic state

**Files:**
- Modify: `src/components/battle/BattleScreen.tsx`

The engineer slot display is around line 410-420. Add resonance/harmonic visual feedback:

Find where slots are rendered (likely a `.map()` over `battle.engineerSlots`). Add a computed resonance state:

```tsx
// Compute resonance states for UI
const slots = battle.engineerSlots || [];
const isHarmonic = slots.length >= 2 && slots.every(s => s.id === slots[0]?.id);
const resonantPairs = new Set<number>();
for (let i = 0; i < slots.length - 1; i++) {
  if (slots[i].id === slots[i + 1].id) {
    resonantPairs.add(i);
    resonantPairs.add(i + 1);
  }
}
```

Then in the slot render, add a CSS class:
```tsx
<div
  key={slot.id + i}
  className={`engineer-slot ${isHarmonic ? 'slot-harmonic' : resonantPairs.has(i) ? 'slot-resonant' : ''}`}
>
```

Add to `src/index.css`:
```css
.engineer-slot.slot-resonant {
  border: 1px solid #fbbf24;  /* epic yellow */
  box-shadow: 0 0 6px rgba(251, 191, 36, 0.4);
}
.engineer-slot.slot-harmonic {
  border: 1px solid #f59e0b;  /* legendary gold */
  box-shadow: 0 0 10px rgba(245, 158, 11, 0.6);
  animation: harmonic-pulse 1.5s ease-in-out infinite;
}
@keyframes harmonic-pulse {
  0%, 100% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.6); }
  50% { box-shadow: 0 0 20px rgba(245, 158, 11, 0.9); }
}
```

**Verify:** `npm run build`

---

## Task 15: Version bump

**Files:**
- Modify: `src/store/gameStore.ts`

Find `GAME_VERSION` at the top of the file:
```ts
// Change from whatever current version to:
const GAME_VERSION = '1.15.0';
```

This ensures any in-progress saves are cleared on load (the save migration logic in gameStore.ts automatically wipes saves when version mismatches).

**Verify:** `npm run build` â€” final clean compile check.

---

## Quick Reference: New Fields Summary

### CardEffect (types/index.ts)
```ts
damagePerDodge?: number;
bonusDamageIfDodgedThisTurn?: boolean;
bonusDamageIfDodgedThisTurnAmount?: number;
dodgeScalesDamage?: number;
doubleBurnOnTarget?: boolean;
tripleBurnOnTarget?: boolean;
damagePerBurn?: number;
consumeBurnOnHit?: boolean;
burnDoTMultiplier?: number;
applyBurnAll?: number;
stress?: number;              // already exists in effects but may need adding to interface
upgradedExhaust?: boolean;    // on CardDef (not CardEffect)
```

### BattleState (types/index.ts)
```ts
dodgedThisTurn: boolean;
dodgeScalesDamage: number;
burnDoTMultiplier: number;
circuitBreakerUsed: boolean;
firstNCardsFreeRemaining: number;
firstEngineerCardFreeUsed: boolean;
```

### EngineerSlot (types/index.ts)
```ts
harmonicEffect?: EngineerEvoke;
```

### EngineerEvoke (types/index.ts)
```ts
applyToSelf?: StatusEffect;
doublePlayerStatus?: boolean;
damageAllScalesWithCounterOffer?: number;
```

### ItemEffect (types/index.ts)
```ts
firstEngineerCardFree?: boolean;
```
